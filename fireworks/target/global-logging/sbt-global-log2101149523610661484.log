[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: initialized: JsonRpcNotificationMessage(2.0, initialized, {})[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: Signal, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///Users/estebanmarin/47deg/coursera/effective-scala/fireworks/src/main/scala/fireworks/Fireworks.scala","languageId":"scala","version":1,"text":"package fireworks\n\nimport doodle.core.{Angle, Color, Point}\nimport scala.util.Random\n\n/**\n * A firework can be in the following states:\n *\n * - [[Waiting]] to be launched,\n * - [[Launched]] (it has not exploded yet, it’s going up in the sky),\n * - [[Exploding]],\n * - [[Done]] (all the particles have burnt).\n */\nsealed trait Firework\n\nobject Firework:\n\n  /**\n   * @return A random initial state of a firework\n   */\n  def init(): Firework = Waiting.init()\n\n  /**\n   * @return The next state of a firework\n   * @param firework The current state of a firework\n   *\n   * If the firework is in the [[Done]] state, it stays in the\n   * same [[Done]] state. Otherwise, the next state is computed\n   * by calling the operation `next` on the underlying state type\n   * (see e.g., the operation `next` in the class [[Waiting]]).\n   *\n   * Hint: choose what to do by pattern matching on the given `firework`.\n   * You will have to use “typed patterns” to match on case classes and\n   * “literal patterns” to match on case objects.\n   */\n  def next(firework: Firework): Firework =\n    ???\n\nend Firework\n\n/**\n * A firework waiting to be launched\n * @param countDown         count-down before transitioning to the [[Launched]] state\n * @param startPosition     location where this firework will be launched\n * @param numberOfParticles number of particles this firework will produce when exploding\n * @param particlesColor    color of this firework\n */\ncase class Waiting(countDown: Int, startPosition: Point, numberOfParticles: Int, particlesColor: Color) extends Firework:\n\n  /**\n   * @return The next state of this firework\n   *\n   * If the [[countDown]] is greater than zero, the firework stays in the [[Waiting]] state and\n   * simply decrements the [[countDown]] of one unit.\n   * Otherwise, it transitions to the [[Launched]] state.\n   *\n   * Note that we use `def` here instead of `val` to avoid evaluating eagerly all the next states.\n   *\n   * Hint: call the method `Launched.init(...)` (with the appropriate arguments) to transition the\n   * firework to the [[Launched]] state.\n   */\n  def next: Firework =\n    if countDown > 0 then\n      copy(countDown = countDown - 1)\n    else ???\n\nend Waiting\n\nobject Waiting:\n\n  /**\n   * @return A randomly initialized firework in a [[Waiting]] state\n   */\n  def init(): Waiting =\n    // Take one color, randomly, among `Settings.colors`\n    val color = Settings.colors(Random.nextInt(Settings.colors.length))\n    val numberOfParticles = 40\n    // Random initial position in the image boundary\n    val position = Point(\n      (Random.nextInt(Settings.width / 2) - Settings.width / 4).toDouble,\n      (-Settings.height / 2).toDouble\n    )\n    // Random count-down between 0 and 60\n    val countDown = Random.nextInt(60)\n    Waiting(countDown, position, numberOfParticles, color)\n\nend Waiting\n\n/**\n * A firework going up in the sky before exploding.\n *\n * We assume that the speed of the firework is constant during this phase.\n *\n * @param countDown         count-down before exploding\n * @param position          current position\n * @param direction         current direction\n * @param numberOfParticles number of particles this firework will produce when exploding\n * @param particlesColor    color of this firework\n */\ncase class Launched(countDown: Int, position: Point, direction: Angle, numberOfParticles: Int, particlesColor: Color) extends Firework:\n  /**\n   * @return The next state of this firework\n   *\n   *         As long as the [[countDown]] is greater than zero, the firework stays in the [[Launched]] state:\n   *         it moves one step further in its [[direction]] and decrements its [[countDown]] of one unit.\n   *         Otherwise, it transitions to the [[Exploding]] state.\n   *\n   *         Hints: use the operation [[Motion.movePoint]] to compute the next position of the firework,\n   *         use the operation [[Exploding.init]] to transition the firework to the [[Exploding]] state,\n   *         and use the constant [[Settings.propulsionSpeed]] for the speed of the firework.\n   */\n  def next: Firework =\n    ???\n\nend Launched\n\nobject Launched:\n\n  /**\n   * @return A firework in a [[Launched]] state, with a random direction\n   * @param position          position of the launch\n   * @param numberOfParticles number of particle this firework will produce when exploding\n   * @param particlesColor    color of this firework\n   */\n  def init(position: Point, numberOfParticles: Int, particlesColor: Color): Launched =\n    // A random vertical direction\n    val direction = Angle(math.Pi / 2 + (Random.nextDouble() - 0.5) / 5)\n    Launched(countDown = 30, position, direction, numberOfParticles, particlesColor)\n\nend Launched\n\n/**\n * A firework that explodes\n * @param countDown count-down before the explosion is finished\n * @param particles Particles of this firework\n */\ncase class Exploding(countDown: Int, particles: Particles) extends Firework:\n\n  /**\n   * @return The next state of this firework\n   *\n   * As long as the [[countDown]] is greater than zero, the firework stays in\n   * the [[Exploding]] state: it updates the state of its [[particles]] and decrements\n   * its [[countDown]].\n   * Otherwise, it transitions to the [[Done]] state.\n   *\n   * Hint: use the operation [[Particles.next]] to compute the next state of the particles\n   *       of this firework.\n   */\n  def next: Firework =\n    ???\n\nend Exploding\n\nobject Exploding:\n\n  /**\n   * @return The initial state of a firework that is exploding\n   * @param numberOfParticles number of particles in the explosion\n   * @param direction         direction of the firework when launched\n   * @param position          position of the explosion\n   * @param color             color of the firework\n   */\n  def init(numberOfParticles: Int, direction: Angle, position: Point, color: Color): Exploding =\n    // Create a group of `numberOfParticles` random particles\n    val particles = List.fill(numberOfParticles)(Particle.init(direction, position, color))\n    Exploding(countDown = 30, Particles(particles))\n\nend Exploding\n\n/**\n * A firework that has been completely burnt\n */\ncase object Done extends Firework\n\n/**\n * A single particle in a firework explosion\n * @param horizontalSpeed horizontal component of the particle speed\n * @param verticalSpeed   vertical component of the particle speed\n * @param position        position of the particle\n * @param color           color of the particle\n */\ncase class Particle(horizontalSpeed: Double, verticalSpeed: Double, position: Point, color: Color):\n\n  /**\n   * @return The next state of this particle\n   *\n   *         Particles are subject to gravity and friction with air.\n   *\n   *         Hint: use the operation [[Motion.drag]] to simulate the friction with the surrounding air,\n   *         and the constant [[Settings.gravity]] to simulate the gravity.\n   */\n  def next: Particle =\n    // Horizontal speed is only subject to air friction, its next value\n    // should be the current value reduced by air friction\n    // Hint: use the operation `Motion.drag`\n    val updatedHorizontalSpeed: Double =\n      ???\n    // Vertical speed is subject to both air friction and gravity, its next\n    // value should be the current value minus the gravity, then reduced by\n    // air friction\n    val updatedVerticalSpeed: Double =\n      ???\n    // Particle position is updated according to its new speed\n    val updatedPosition = Point(position.x + updatedHorizontalSpeed, position.y + updatedVerticalSpeed)\n    // Construct a new particle with the updated position and speed\n    ???\n\nend Particle\n\n// --- Assignment ends here! Once you have reached this point you\n// --- can run your program (invoke the `run` sbt task) and enjoy\n// --- the show! … or fix your implementation, if necessary…\n\n/**\n * A group of particles constituting an explosion\n * @param value group of particles\n */\ncase class Particles(value: List[Particle]):\n  /**\n   * @return The next state of this group of particles\n   */\n  def next: Particles = Particles(value.map(particle => particle.next))\n\nend Particles\n\nobject Particle:\n\n  /**\n   * @return The initial state of a particle\n   * @param initialDirection direction of the firework during its [[Launched]] phase\n   * @param position         position of the particle\n   * @param color            color of the particle\n   */\n  def init(initialDirection: Angle, position: Point, color: Color): Particle =\n    val angle = initialDirection + Angle(Random.nextDouble() * (math.Pi / 4) - math.Pi / 8)\n    val velocity = Random.nextDouble() * 10 + 20\n    Particle(angle.cos * velocity, angle.sin * velocity, position, color)\n\nend Particle\n\n/**\n * Utility operations to handle motion\n */\nobject Motion:\n\n  /**\n   * @return The next position of the given `point`, assuming that it moves towards the given\n   *         `direction` at the given `speed`\n   * @param point     current position of the point\n   * @param direction direction of the point\n   */\n  def movePoint(point: Point, direction: Angle, speed: Double): Point =\n    Point(point.x + direction.cos * speed, point.y + direction.sin * speed)\n\n  /**\n   * @return The given `speed` after applying friction to it\n   */\n  def drag(speed: Double): Double =\n    if speed > Settings.friction then\n      math.max(speed - Settings.friction, 0)\n    else if speed < -Settings.friction then\n      math.min(speed + Settings.friction, 0)\n    else\n      0\n\nend Motion\n\nobject Settings:\n\n  val width = 800\n  val height = 600\n  val colors: Array[Color] = Array(Color.red, Color.yellow, Color.white, Color.blue, Color.violet)\n\n  // These values have no standard units. They just work well for the animation.\n  val friction = 0.2\n  val gravity = 1.5\n  val propulsionSpeed = 8.0\n\nend Settings\n"}})[0m
[0m[[0m[0minfo[0m] [0m[0mUpdating [0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":3,"message":"Updating "})[0m
[0m[[0m[0minfo[0m] [0m[0mResolved  dependencies[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":3,"message":"Resolved  dependencies"})[0m
[0m[[0m[0minfo[0m] [0m[0mUpdating [0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":3,"message":"Updating "})[0m
[0m[[0m[0minfo[0m] [0m[0mResolved  dependencies[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":3,"message":"Resolved  dependencies"})[0m
[0m[[0m[0minfo[0m] [0m[0mUpdating [0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":3,"message":"Updating "})[0m
[0m[[0m[0minfo[0m] [0m[0mResolved  dependencies[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":3,"message":"Resolved  dependencies"})[0m
[0m[[0m[0minfo[0m] [0m[0mUpdating [0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":3,"message":"Updating "})[0m
[0m[[0m[0minfo[0m] [0m[0mResolved  dependencies[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":3,"message":"Resolved  dependencies"})[0m
[0m[[0m[0minfo[0m] [0m[0mFetching artifacts of [0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":3,"message":"Fetching artifacts of "})[0m
[0m[[0m[0minfo[0m] [0m[0mFetched artifacts of [0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":3,"message":"Fetched artifacts of "})[0m
[0m[[0m[0mdebug[0m] [0m[0manalysis location (/Users/estebanmarin/47deg/coursera/effective-scala/fireworks/target/scala-3.1.0/zinc/inc_compile_3.zip,true)[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 111 s (01:51), completed Sep 23, 2022, 7:39:12 PM[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled request received: shutdown: JsonRpcRequestMessage(2.0, ♨1, shutdown, null})[0m
